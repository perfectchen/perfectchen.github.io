{"meta":{"title":"Li Yanchen's Blog","subtitle":null,"description":null,"author":"Li Yanchen","url":"http://yoursite.com"},"pages":[{"title":"","date":"2017-08-20T06:00:32.309Z","updated":"2017-08-20T06:00:32.309Z","comments":true,"path":"404.html","permalink":"http://yoursite.com/404.html","excerpt":"","text":""},{"title":"about","date":"2017-10-02T03:38:30.000Z","updated":"2017-10-02T03:38:30.602Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"分类","date":"2017-08-20T05:48:22.000Z","updated":"2017-08-20T06:00:32.299Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"cover_picture","date":"2017-10-02T03:46:58.000Z","updated":"2017-10-02T03:46:58.738Z","comments":true,"path":"cover-picture/index.html","permalink":"http://yoursite.com/cover-picture/index.html","excerpt":"","text":""},{"title":"标签","date":"2017-08-20T05:44:13.000Z","updated":"2017-08-20T05:47:21.993Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"矩阵快速幂","slug":"矩阵快速幂","date":"2017-09-10T11:34:12.000Z","updated":"2017-10-02T04:26:03.161Z","comments":true,"path":"2017/09/10/矩阵快速幂/","link":"","permalink":"http://yoursite.com/2017/09/10/矩阵快速幂/","excerpt":"","text":"number number numberTime Limit: 2000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Problem DescriptionWe define a sequence F: . F0=0,F1=1;. Fn=Fn−1+Fn−2 (n≥2). Give you an integer k, if a positive number n can be expressed byn=Fa1+Fa2+…+Fak where 0≤a1≤a2≤⋯≤ak, this positive number is mjf−good. Otherwise, this positive number is mjf−bad.Now, give you an integer k, you task is to find the minimal positive mjf−bad number.The answer may be too large. Please print the answer modulo 998244353. InputThere are about 500 test cases, end up with EOF.Each test case includes an integer k which is described above. (1≤k≤109) OutputFor each case, output the minimal mjf−bad number mod 998244353. Sample Input1 Sample Output4 此题首先规律就不好找(本人感觉),最后发现规律是从第六项开始的2n项斐波那契数减1。也就是第4+2k项的斐波那契数减1。然后写个循环超时。。。最后听教练说用矩阵的快速幂。(从未听说过的高大上词汇) 线性代数没学，于是也没有听懂。附上教练的正方形代码，以后再慢慢看。12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;long long c[2][2] = &#123;&#123;1,0&#125;,&#123;0,1&#125;&#125;;long long a[2][2]=&#123;0,1,1,1&#125;,b[2][2];int main()&#123; int k; while(~scanf(\"%d\", &amp;k)) &#123; k=2*k-1; c[0][0]=1; c[0][1]=0; c[1][0]=0; c[1][1]=1; a[0][0]=0; a[0][1]=1; a[1][0]=1; a[1][1]=1; while(k&gt;0) &#123; if(k%2==1) &#123; b[0][0]=(c[0][0]*a[0][0]+c[0][1]*a[1][0])%998244353; b[0][1]=(c[0][0]*a[0][1]+c[0][1]*a[1][1])%998244353; b[1][0]=(c[1][0]*a[0][0]+c[1][1]*a[1][0])%998244353; b[1][1]=(c[1][0]*a[0][1]+c[1][1]*a[1][1])%998244353; c[0][0]=b[0][0]; c[0][1]=b[0][1]; c[1][0]=b[1][0]; c[1][1]=b[1][1]; &#125; b[0][0]=(a[0][0]*a[0][0]+a[0][1]*a[1][0])%998244353; b[0][1]=(a[0][0]*a[0][1]+a[0][1]*a[1][1])%998244353; b[1][0]=(a[1][0]*a[0][0]+a[1][1]*a[1][0])%998244353; b[1][1]=(a[1][0]*a[0][1]+a[1][1]*a[1][1])%998244353; a[0][0]=b[0][0]; a[0][1]=b[0][1]; a[1][0]=b[1][0]; a[1][1]=b[1][1]; k=k/2; &#125; cout&lt;&lt;(2*c[0][1]+3*c[1][1]-1)%998244353&lt;&lt;endl; &#125; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}],"tags":[{"name":"ACM-ICPC","slug":"ACM-ICPC","permalink":"http://yoursite.com/tags/ACM-ICPC/"}]},{"title":"种类并查集","slug":"种类并查集","date":"2017-08-24T04:03:47.000Z","updated":"2017-10-02T04:26:09.925Z","comments":true,"path":"2017/08/24/种类并查集/","link":"","permalink":"http://yoursite.com/2017/08/24/种类并查集/","excerpt":"","text":"poj 1182 食物链Time Limit: 1000MS Memory Limit: 10000K Description动物王国中有三类动物A,B,C，这三类动物的食物链构成了有趣的环形。A吃B， B吃C，C吃A。现有N个动物，以1－N编号。每个动物都是A,B,C中的一种，但是我们并不知道它到底是哪一种。有人用两种说法对这N个动物所构成的食物链关系进行描述：第一种说法是”1 X Y”，表示X和Y是同类。第二种说法是”2 X Y”，表示X吃Y。此人对N个动物，用上述两种说法，一句接一句地说出K句话，这K句话有的是真的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话。1） 当前的话与前面的某些真的话冲突，就是假话；2） 当前的话中X或Y比N大，就是假话；3） 当前的话表示X吃X，就是假话。你的任务是根据给定的N（1 &lt;= N &lt;= 50,000）和K句话（0 &lt;= K &lt;= 100,000），输出假话的总数。 Input第一行是两个整数N和K，以一个空格分隔。以下K行每行是三个正整数 D，X，Y，两数之间用一个空格隔开，其中D表示说法的种类。若D=1，则表示X和Y是同类。若D=2，则表示X吃Y。 Output只有一个整数，表示假话的数目。 Sample Input100 71 101 12 1 22 2 32 3 31 1 32 3 11 5 5 Sample Output3 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;int r[50001],pre[50001];int d;int fun(int x)&#123; if(x==pre[x]) return x; int t=pre[x]; pre[x]=fun(pre[x]); r[x]=(r[x]+r[t])%3;//回溯判断此节点与头结点的关系 return pre[x];&#125;void join(int x,int y)&#123; int a=fun(x); int b=fun(y); //if(a==b) return; pre[a]=b; r[a]=(r[y]-d+6-r[x])%3;//判断合并之后a与头节点的关系&#125;void set(int n)&#123; for(int i=1;i&lt;=n;i++) &#123; pre[i]=i; r[i]=0; &#125;&#125;int main()&#123; int n,k; int x,y; int num=0; scanf(\"%d%d\",&amp;n,&amp;k); set(n); while(k--) &#123; scanf(\"%d%d%d\",&amp;d,&amp;x,&amp;y); //cout&lt;&lt;r[x]&lt;&lt;r[y]&lt;&lt;endl; if(d==1) d=0; if(x&gt;n||y&gt;n||(d==2&amp;&amp;x==y)) &#123;num++;continue;&#125; if(fun(x)==fun(y)) &#123; if((r[x]==r[y]&amp;&amp;d==0)||(r[x]==2&amp;&amp;r[y]==1&amp;&amp;d==2)||(r[x]==0&amp;&amp;r[y]==2&amp;&amp;d==2)||(r[x]==1&amp;&amp;r[y]==0&amp;&amp;d==2)) num=num; else num++; &#125; else join(x,y); &#125; printf(\"%d\\n\",num); return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"},{"name":"并查集","slug":"算法/并查集","permalink":"http://yoursite.com/categories/算法/并查集/"}],"tags":[{"name":"算法题目","slug":"算法题目","permalink":"http://yoursite.com/tags/算法题目/"}]},{"title":"线段树模板题","slug":"hdu-1166","date":"2017-08-20T08:28:28.000Z","updated":"2017-10-01T13:41:11.494Z","comments":true,"path":"2017/08/20/hdu-1166/","link":"","permalink":"http://yoursite.com/2017/08/20/hdu-1166/","excerpt":"","text":"hdu 1166 敌兵布阵Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others) Problem Description C国的死对头A国这段时间正在进行军事演习，所以C国间谍头子Derek和他手下Tidy又开始忙乎了。A国在海岸线沿直线布置了N个工兵营地,Derek和Tidy的任务就是要监视这些工兵营地的活动情况。由于采取了某种先进的监测手段，所以每个工兵营地的人数C国都掌握的一清二楚,每个工兵营地的人数都有可能发生变动，可能增加或减少若干人手,但这些都逃不过C国的监视。 中央情报局要研究敌人究竟演习什么战术,所以Tidy要随时向Derek汇报某一段连续的工兵营地一共有多少人,例如Derek问:“Tidy,马上汇报第3个营地到第10个营地共有多少人!”Tidy就要马上开始计算这一段的总人数并汇报。但敌兵营地的人数经常变动，而Derek每次询问的段都不一样，所以Tidy不得不每次都一个一个营地的去数，很快就精疲力尽了，Derek对Tidy的计算速度越来越不满:”你个死肥仔，算得这么慢，我炒你鱿鱼!”Tidy想：“你自己来算算看，这可真是一项累人的工作!我恨不得你炒我鱿鱼呢!”无奈之下，Tidy只好打电话向计算机专家Windbreaker求救,Windbreaker说：“死肥仔，叫你平时做多点acm题和看多点算法书，现在尝到苦果了吧!”Tidy说：”我知错了。。。”但Windbreaker已经挂掉电话了。Tidy很苦恼，这么算他真的会崩溃的，聪明的读者，你能写个程序帮他完成这项工作吗？不过如果你的程序效率不够高的话，Tidy还是会受到Derek的责骂的. Input 第一行一个整数T，表示有T组数据。 每组数据第一行一个正整数N（N&lt;=50000）,表示敌人有N个工兵营地，接下来有N个正整数,第i个正整数ai代表第i个工兵营地里开始时有ai个人（1&lt;=ai&lt;=50）。 接下来每行有一条命令，命令有4种形式： (1) Add i j,i和j为正整数,表示第i个营地增加j个人（j不超过30） (2)Sub i j ,i和j为正整数,表示第i个营地减少j个人（j不超过30）; (3)Query i j ,i和j为正整数,i&lt;=j，表示询问第i到第j个营地的总人数; (4)End 表示结束，这条命令在每组数据最后出现; 每组数据最多有40000条命令 Output 对第i组数据,首先输出“Case i:”和回车, 对于每个Query询问，输出一个整数并回车,表示询问的段中的总人数,这个数保持在int以内。 Sample Input123456789101101 2 3 4 5 6 7 8 9 10Query 1 3Add 3 6Query 2 7Sub 10 2Add 6 3Query 3 10End Sample Output1234Case 1:63359 此题为线段树的模板题，也是我做的第一个线段树的题。具体方法参照如下博客go12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;iostream&gt;#include &lt;cstdio&gt;#define M 50005using namespace std;int sum[M&lt;&lt;2];void pushup(int rt)&#123; sum[rt]=sum[rt&lt;&lt;1]+sum[rt&lt;&lt;1|1];&#125;void built(int l,int r,int rt)&#123; if(l==r) &#123; scanf(\"%d\",&amp;sum[rt]); return; &#125; int m=(l+r)&gt;&gt;1; built(l,m,rt&lt;&lt;1); built(m+1,r,rt&lt;&lt;1|1); pushup(rt);&#125;void update(int p,int add,int l,int r,int rt)&#123; if(l==r) &#123; sum[rt]+=add; return; &#125; int m=(l+r)&gt;&gt;1; if(p&lt;=m) update(p,add,l,m,rt&lt;&lt;1); else update(p,add,m+1,r,rt&lt;&lt;1|1); pushup(rt);&#125;int Query(int L,int R,int l,int r,int rt)&#123; if(L&lt;=l&amp;&amp;r&lt;=R) return sum[rt]; int m=(l+r)&gt;&gt;1; int ans=0; if(L&lt;=m) ans+=Query(L,R,l,m,rt&lt;&lt;1); if(R&gt;m) ans+=Query(L,R,m+1,r,rt&lt;&lt;1|1); return ans;&#125;int main()&#123; int T,n,a,b; cin&gt;&gt;T; int caset=T; while(T--) &#123; printf(\"Case %d:\\n\",caset-T); scanf(\"%d\",&amp;n); built(1,n,1); char op[10]; while(scanf(\"%s\",op)!=EOF&amp;&amp;op[0]!='E') &#123; scanf(\"%d%d\",&amp;a,&amp;b); if(op[0]=='Q') printf(\"%d\\n\",Query(a,b,1,n,1)); if(op[0]=='S') update(a,-b,1,n,1); if(op[0]=='A') update(a,b,1,n,1); &#125; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"},{"name":"线段树","slug":"算法/线段树","permalink":"http://yoursite.com/categories/算法/线段树/"}],"tags":[{"name":"算法题目","slug":"算法题目","permalink":"http://yoursite.com/tags/算法题目/"}]},{"title":"线段树成段更新","slug":"poj-3468","date":"2017-08-20T07:40:33.000Z","updated":"2017-10-01T13:37:05.992Z","comments":true,"path":"2017/08/20/poj-3468/","link":"","permalink":"http://yoursite.com/2017/08/20/poj-3468/","excerpt":"","text":"poj 3468 A Simple Problem with IntegersTime Limit: 5000MS Memory Limit: 131072KCase Time Limit: 2000MS Description You have N integers, A1, A2, … , AN. You need to deal with two kinds of operations. One type of operation is to add some given number to each number in a given interval. The other is to ask for the sum of numbers in a given interval. Input The first line contains two numbers N and Q. 1 ≤ N,Q ≤ 100000. The second line contains N numbers, the initial values of A1, A2, … , AN. -1000000000 ≤ Ai ≤ 1000000000. Each of the next Q lines represents an operation. “C a b c” means adding c to each of Aa, Aa+1, … , Ab. -10000 ≤ c ≤ 10000. “Q a b” means querying the sum of Aa, Aa+1, … , Ab. Output You need to answer all Q commands in order. One answer in a line. Sample Input123456710 51 2 3 4 5 6 7 8 9 10Q 4 4Q 1 10Q 2 4C 3 6 3Q 2 4 Sample Output1234455915 Hint The sums may exceed the range of 32-bit integers. 成段更新,简单来说就是每次更新的时候不要更新到底,用延迟标记使得更新延迟到下次需要更新or询问到的时候线段树功能:update:成段增减 query:区间求和123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;iostream&gt;#include &lt;cstdio&gt;#define MAX 100002using namespace std;long long sum[MAX&lt;&lt;2];long long col[MAX&lt;&lt;2];void pushdown(int rt,int m)&#123; if(col[rt]) &#123; col[rt&lt;&lt;1]+=col[rt]; col[rt&lt;&lt;1|1]+=col[rt]; sum[rt&lt;&lt;1]+=(m-(m&gt;&gt;1))*col[rt]; sum[rt&lt;&lt;1|1]+=(m&gt;&gt;1)*col[rt]; col[rt]=0; &#125;&#125;void built(int l,int r,int rt)&#123; col[rt]=0; if(l==r) &#123; scanf(\"%lld\",&amp;sum[rt]); return ; &#125; int m=(l+r)&gt;&gt;1; built(l,m,rt&lt;&lt;1); built(m+1,r,rt&lt;&lt;1|1); sum[rt]=sum[rt&lt;&lt;1]+sum[rt&lt;&lt;1|1];&#125;void update(int x,int y,int c,int l,int r,int rt)&#123; if(x&lt;=l&amp;&amp;y&gt;=r) &#123; sum[rt]+=(long long)(r-l+1)*c; col[rt]+=c; return; &#125; pushdown(rt,r-l+1); int m=(l+r)&gt;&gt;1; if(x&lt;=m) update(x,y,c,l,m,rt&lt;&lt;1); if(y&gt;m) update(x,y,c,m+1,r,rt&lt;&lt;1|1); sum[rt]=sum[rt&lt;&lt;1]+sum[rt&lt;&lt;1|1];&#125;long long query(int x,int y,int l,int r,int rt)&#123; if(x&lt;=l&amp;&amp;y&gt;=r) &#123; return sum[rt]; &#125; pushdown(rt,r-l+1); int m=(r+l)/2; long long re=0; if(x&lt;=m) re+=query(x,y,l,m,rt&lt;&lt;1); if(y&gt;m) re+=query(x,y,m+1,r,rt&lt;&lt;1|1); return re;&#125;int main()&#123; int n,q; scanf(\"%d%d\",&amp;n,&amp;q); built(1,n,1); while(q--) &#123; char ch[2]; scanf(\"%s\",ch); if(ch[0]=='C') &#123; int a,b,c; scanf(\"%d%d%d\",&amp;a,&amp;b,&amp;c); update(a,b,c,1,n,1); &#125; if(ch[0]=='Q') &#123; int a,b; scanf(\"%d%d\",&amp;a,&amp;b); long long num=query(a,b,1,n,1); printf(\"%lld\\n\",num); &#125; &#125; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"},{"name":"线段树","slug":"算法/线段树","permalink":"http://yoursite.com/categories/算法/线段树/"}],"tags":[{"name":"算法题目","slug":"算法题目","permalink":"http://yoursite.com/tags/算法题目/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-07-08T12:25:20.475Z","updated":"2017-08-22T14:59:07.064Z","comments":true,"path":"2017/07/08/hello-world/","link":"","permalink":"http://yoursite.com/2017/07/08/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}